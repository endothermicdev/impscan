#!/usr/bin/env python3
from pyln.client import Plugin, RpcError
from enum import Enum

plugin = Plugin()

# Still experimental, not interop tested/approved.
pending_features = {"OPT_DUAL_FUND": 28,
                    "OPTION_WILL_FUND_FOR_FOOD": 30,
                    "OPTION_INV_GOSSIP": 34,
                    "OPTION_SCHNORR_GOSSIP": 38,
                    "CLN_WANT_PEER_STORAGE": 40,
                    "CLN_PROVIDE_PEER_STORAGE": 42,
                    "KEYSEND": 54,
                    "TRUSTED_SWAP_IN_PROVIDER": 142,
                    "TRUSTED_BACKUP_CLIENT": 144,
                    "TRUSTED_BACKUP_PROVIDER": 146,
                    "LSPS0_CONFORMANCE": 728
                    }

# Established features from BOLT7
est_features = {"OPTION_DATA_LOSS_PROTECT": 0,
                "INITIAL_ROUTING_SYNC": 2,
                "OPTION_UPFRONT_SHUTDOWN_SCRIPT": 4,
                "OPT_GOSSIP_QUERIES": 6,
                "VAR_ONION_OPTIN": 8,
                "GOSSIP_QUERIES_EX": 10,
                "OPTION_STATIC_REMOTEKEY": 12,
                "PAYMENT_SECRET": 14,
                "BASIC_MPP": 16,
                "OPTION_SUPPORT_LARGE_CHANNEL": 18,
                "OPTION_ANCHOR_OUTPUTS": 20,
                "OPTION_ANCHORS_ZERO_FEE_HTLC_TX": 22,
                "OPTION_ROUTE_BLINDING": 24,
                "OPTION_SHUTDOWN_ANYSEGWIT": 26,
                "OPTION_CHANNEL_TYPE": 44,
                "OPTION_SCID_ALIAS": 46,
                "OPTION_PAYMENT_METADATA": 48,
                "OPT_ZEROCONF": 50}

possFeatures = {**pending_features, **est_features}


class Feature(Enum):
    MANDATORY = 'mandatory'
    OPTIONAL = 'optional'
    NOT_MANDATORY = 'not mandatory'
    NOT_OPTIONAL = 'not optional'
    NOT_SET = 'not set'


class Heuristic(object):
    """A set of features and flagging used to fingerprint a
    lightning node to a certain implementation."""
    def __init__(self, implementation_name, **features):
        self.name = implementation_name
        self.features = features

    def test_feature(self, features, bitnumber):
        """Test for mandatory or optional positions."""
        return ((features & (1 << bitnumber)) != 0)

    def test(self, features):
        """Test a features bitfield against this heuristic."""
        assert isinstance(features, int)
        for fname, fvalue in self.features.items():
            if fvalue == Feature.MANDATORY:
                if not self.test_feature(features, possFeatures[fname]):
                    return False
            if fvalue == Feature.OPTIONAL:
                if not self.test_feature(features, possFeatures[fname]+1):
                    return False
            if fvalue == Feature.NOT_MANDATORY:
                if self.test_feature(features, possFeatures[fname]):
                    return False
            if fvalue == Feature.NOT_OPTIONAL:
                if self.test_feature(features, possFeatures[fname]):
                    return False
            if fvalue == Feature.NOT_SET:
                if self.test_feature(features, possFeatures[fname]) or\
                   self.test_feature(features, possFeatures[fname]+1):
                    return False
        return True


CLN_DF_NEW = Heuristic("CLN v23.02+ Dual-Fund",
                       OPT_DUAL_FUND=Feature.OPTIONAL,
                       OPTION_ROUTE_BLINDING=Feature.OPTIONAL,
                       OPTION_DATA_LOSS_PROTECT=Feature.OPTIONAL,
                       OPTION_STATIC_REMOTEKEY=Feature.NOT_MANDATORY,
                       GOSSIP_QUERIES_EX=Feature.OPTIONAL)

CLN_DF_OLD = Heuristic("CLN Broken Dual-Fund",
                       OPT_DUAL_FUND=Feature.OPTIONAL,
                       OPTION_DATA_LOSS_PROTECT=Feature.OPTIONAL,
                       OPTION_STATIC_REMOTEKEY=Feature.NOT_MANDATORY,
                       GOSSIP_QUERIES_EX=Feature.OPTIONAL)

Eclair = Heuristic("Eclair",
                   OPTION_SUPPORT_LARGE_CHANNEL=Feature.OPTIONAL,
                   OPTION_ANCHORS_ZERO_FEE_HTLC_TX=Feature.OPTIONAL,
                   OPTION_DATA_LOSS_PROTECT=Feature.OPTIONAL)

LND = Heuristic("LND", OPTION_DATA_LOSS_PROTECT=Feature.MANDATORY)

CLN = Heuristic("CLN",
                OPTION_DATA_LOSS_PROTECT=Feature.OPTIONAL,
                OPTION_STATIC_REMOTEKEY=Feature.NOT_MANDATORY,
                GOSSIP_QUERIES_EX=Feature.OPTIONAL)

LDK = Heuristic("LDK",
                VAR_ONION_OPTIN=Feature.MANDATORY)

Unknown = Heuristic("2200",
                    VAR_ONION_OPTIN=Feature.OPTIONAL,
                    OPTION_STATIC_REMOTEKEY=Feature.OPTIONAL)


# heuristics should be ordered from most unique/restrictive features to least
all_heuristics = [CLN_DF_NEW, CLN_DF_OLD, Eclair, LND, CLN, LDK, Unknown]


class MissingNode(Exception):
    """node_id was not found by lightningd"""


class ListNodesException(Exception):
    """listnodes rpc failure"""


def test_feature(features, bitnumber):
    """Test for mandatory or optional positions."""
    assert isinstance(features, int)
    return (features & (1 << bitnumber)) != 0


def identifyFingerprint(feat):
    assert isinstance(feat, int)
    for heuristic in all_heuristics:
        if heuristic.test(feat):
            return heuristic.name
    return "indef"


def unknownFeatures(features):
    known_features = []
    unknown = []
    for _, feat_num in possFeatures.items():
        known_features.append(feat_num)
        known_features.append(feat_num+1)
    for bit in range(len(bin(features))-2):
        if (test_feature(features, bit) and (bit not in known_features)):
            unknown.append(bit)
    return unknown


def decodeFeatures(features):
    """pass a feature bit string (HEX) and return a human readable output."""
    assert isinstance(features, str)
    try:
        f = int(features, 16)
    except ValueError:
        return ["feature bit decode failed. (hex encoding required)"]
    result = {}
    for name, feat_num in possFeatures.items():
        if test_feature(f, feat_num+1):
            result.update({"{:<4} {}".format(feat_num+1, name): "optional"})
        elif test_feature(f, feat_num):
            result.update({"{:<4} {}".format(feat_num, name): "mandatory"})
    if unknownFeatures(f):
        result.update({"Unknown features": unknownFeatures(f)})
    return result


def queryNodeFeatures(nodeid):
    if len(str(nodeid)) != 66:
        raise Exception("nodeid must be 33 bytes (66 hex chars)")
    try:
        query = plugin.rpc.listnodes(str(nodeid))
    except RpcError as err:
        if ('code', -32602) in err.error.items():
            raise MissingNode(f"node_id {nodeid} not found") from err
        raise ListNodesException(("Error encountered during call to "
                                  f"listnodes: {err}")) from err
    if len(query['nodes']) == 0:
        raise MissingNode(f"node_id {nodeid} not found")
    node = query['nodes'][0]
    return node["features"]


def singleNodeDecode(nodeid):
    try:
        return decodeFeatures(queryNodeFeatures(nodeid))
    except MissingNode:
        return f'node_id {nodeid} not found'


def testNodes(test_items):
    """feed a json dict of node_id:heuristic pairs and this will fingerprint
    the nodes and validate that they match the desired heuristic. A list of
    nodes from all implementations will validate that all the heuristics
    remain effective."""
    if not isinstance(test_items, dict):
        return "test argument requires a json dict of format \
'{\"node_id\":\"heuristic\"}'"
    answer = []
    for node, test_heur in test_items.items():
        feats = queryNodeFeatures(node)
        fingerprint = identifyFingerprint(int(feats, 16))
        answer.append({"node_id": node,
                       "features": feats,
                       "test heuristic": test_heur,
                       "fingerprint": fingerprint,
                       "status": fingerprint == test_heur})
    return answer


def fullScan():
    """Fingerprint all nodes on the network using all heuristics."""
    for heuristic in all_heuristics:
        for feature in heuristic.features.keys():
            if feature not in possFeatures.keys():
                return {"error": f"{feature} not a possible feature "
                        f"({heuristic.name} heuristic)"}
    plugin.log("impscan calling listnodes via rpc")
    nodes = plugin.rpc.listnodes()['nodes']
    plugin.log(f"impscan: listnodes returned {len(nodes)} items")
    tally = {}
    for heuristic in all_heuristics:
        tally.update({heuristic.name: 0})
    tally.update({"indef": 0, "no features": 0, "total": len(nodes)})
    indefs = []

    for node in nodes:
        if "features" not in node:
            tally["no features"] += 1
            continue
        if node["features"] is None or node["features"] == '':
            tally["no features"] += 1
            continue
        fingerprint = identifyFingerprint(int(node["features"], 16))
        if fingerprint == "indef":
            indefs.append(node)
        tally[fingerprint] += 1

    return tally


@plugin.method("impscan")
def impscan(plugin, **kwargs):
    """Estimate breakdown of various lightning implementations on the network.
    This relies on the listnodes command and feature bits. Work in progress."""
    possible_arguments = ["node", "features", "test"]
    # Run analysis on all network nodes
    if not kwargs:
        return fullScan()
    for cmd, string in kwargs.items():
        if cmd not in possible_arguments:
            return (f"unrecognized keyword '{cmd}'. Try one of "
                    f"`{'`, `'.join(possible_arguments)}`.")
        if cmd == "node":
            return singleNodeDecode(string)
        if cmd == "features":
            return decodeFeatures(string)
        if cmd == "test":
            return testNodes(string)


@plugin.init()
def init(options, configuration, plugin, **kwargs):
    plugin.log("Plugin impscan.py initialized")


plugin.run()
